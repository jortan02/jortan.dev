[
	{
	  "question": "What is Jordan's educational background?",
	  "answer": "Jordan earned both his bachelor's and master's degrees in Computer Science from the University of Utah.",
	  "contexts": []
	},
	{
	  "question": "What kind of roles is Jordan interested in?",
	  "answer": "Jordan is interested in roles involving machine learning, full-stack development, and research-driven product work.",
	  "contexts": []
	},
	{
	  "question": "How can I get in touch with Jordan?",
	  "answer": "The best way to contact Jordan is through his LinkedIn profile.",
	  "contexts": []
	},
	{
	  "question": "What was the final test accuracy for the Convolutional Neural Network project?",
	  "answer": "The project achieved a test accuracy of 68.7% on the CIFAR-10 dataset, surpassing the benchmark of 62%.",
	  "contexts": [
		"---\npublished: true\ntitle: Convolutional Neural Network\ndescription: Implementation of a complete CNN architecture using only NumPy for image classification on CIFAR-10 dataset.\ndate: 2023-10-08\ncategory: Project\nskills: [Python, NumPy]\n---\n\n### Overview\n\nThis coursework project for CS 5353 (Deep Learning) demonstrates a comprehensive understanding of neural network fundamentals through the implementation of a complete convolutional neural network (CNN) from scratch using only NumPy. The project focuses on the mathematical principles behind CNNs while achieving competitive results on the CIFAR-10 image classification dataset without relying on deep learning libraries.\n\n### Key Achievements\n\n- Achieved 68.7% test accuracy on CIFAR-10\n- Surpassed the benchmark accuracy of 62%\n- Built all core CNN components from first principles\n- Successfully trained a multi-layer model using only NumPy\n\n### Technical Implementation\n\n- Implemented convolutional layers with custom kernels\n- Developed max pooling layers for downsampling\n- Created batch normalization for training stability\n- Built ReLU activation and softmax output layers\n- Designed fully connected layers for classification\n- Wrote backpropagation logic for all components\n"
	  ]
	},
	{
	  "question": "In the Selective Unlearning project, how was the ensemble model structured?",
	  "answer": "The architecture used was an ensemble of five ResNet-18 models, each with 11.4M parameters, which was compared against a single monolithic ResNet-152 model.",
	  "contexts": [
		"---\npublished: true\ntitle: Selective Unlearning of Training Data Without Complete Retraining\ndescription: A research project exploring efficient machine unlearning techniques using ensemble models to protect user privacy while maintaining model performance.\ndate: 2023-06-28\ncategory: Research\nskills: [Python, PyTorch]\nurl: https://docs.google.com/presentation/d/1ZiuXadZMVvYtrFtaREbwJNeWGyYnZwKc-gf4cEZRP-Y/edit?usp=sharing\nrepository: machine_unlearning\n---\n\n### Overview\n\nThis NSF-sponsored research project investigates machine unlearning, the process of removing the influence of specific data points from trained machine learning models. This is essential for privacy-preserving systems where users may request their data to be deleted, and retraining a model from scratch is inefficient or impractical.\n\nTo address this, we propose an ensemble-based method: a collection of models, each trained on random subsets of the dataset. When unlearning is required, only the affected models are replaced, avoiding full retraining and enabling continual learning.\n\n### Key Findings\n\n- Ensemble models trained on randomized data subsets can support selective unlearning by retraining only a subset of the ensemble\n- Achieved better validation loss and accuracy than a larger monolithic ResNet-152 model despite using fewer total parameters\n- The system supports online-style learning, where data is introduced incrementally and unlearning requests can be processed efficiently\n- Demonstrated that privacy compliance and model performance need not be mutually exclusive\n\n### Technical Implementation\n\n- Architecture: Ensemble of five ResNet-18 models (11.4M parameters each)\n- Baseline Comparison: Single ResNet-152 (58.5M parameters) without unlearning\n- Training Strategy:\n  - Models trained on chunks of CIFAR-10 in sequence\n  - Each model receives a random subset of each chunk\n  - When data must be unlearned, models that trained on it are marked invalid\n  - Invalid models are replaced and retrained on the latest available data\n- Evaluation:\n  - Validation accuracy and loss tracked after each training phase\n  - Visualizations highlight ensemble progress vs. baseline\n"
	  ]
	},
	{
	  "question": "What networking protocol was used for the TankWars game?",
	  "answer": "The TankWars game used a TCP-based client-server model to handle game synchronization and communication between the server and multiple clients.",
	  "contexts": [
		"---\npublished: true\ntitle: TankWars\ndescription: A real-time multiplayer tank battle game featuring client-server architecture, synchronized gameplay, and MVC design principles.\ndate: 2021-12-02\ncategory: Desktop App\nskills: [C#, WinForms, TCP, JSON]\n---\n\n![TankWars screenshot](/images/portfolio/TankWars.png)\n\n### Overview\n\nTankWars is a real-time multiplayer tank battle game developed as a pair programming project for CS 3500 (Software Design I) at the University of Utah. It showcases advanced concepts in software architecture, network synchronization, and game development. The game enables players to engage in competitive tank combat, supported by a robust client-server model and real-time event handling.\n\n### Key Features\n\n- Real-time multiplayer gameplay across multiple clients\n- Client-server architecture for centralized control and consistency\n- Synchronized game state to ensure fairness\n- Interactive tank movement and combat mechanics\n- Dynamic events and real-time score tracking\n\n### Technical Implementation\n\n- Followed MVC architecture for modular, maintainable code\n- Built a TCP-based client-server model for game synchronization\n- Server maintained the authoritative game state and validated player actions\n- Clients rendered game state and sent input events to the server\n- Designed a synchronized game loop and entity tracking system\n- Implemented event-driven logic for collisions and scorekeeping\n- Serialized game events and world updates using JSON\n- Developed the game interface with WinForms for real-time rendering\n"
	  ]
	},
	{
	  "question": "What technologies were used in the Drawing App?",
	  "answer": "The Drawing App was built with Kotlin for the Android platform and used Firebase for user authentication and real-time database capabilities. It also incorporated C++ for image augmentation and used Jetpack components for UI and state management.",
	  "contexts": [
		 "---\npublished: true\ntitle: Drawing App\ndescription: An Android drawing application with user authentication, drawing tools, and social sharing features.\ndate: 2024-02-09\ncategory: Mobile App\nskills: [Kotlin, Android, Firebase, C++, Jetpack]\n---\n\n![Drawing App screenshot](/images/portfolio/Drawing_App.png)\n\n### Overview\n\nThis coursework project for CS 4530 (Mobile Application Programming) demonstrates modern Android development practices and real-time collaboration features. The Drawing App is a feature-rich Android application that allows users to create, save, and share digital artwork. Built using Kotlin and following the MVVM architecture pattern, the app offers a smooth and intuitive drawing experience with robust user authentication, image augmentation, and cloud-backed persistence.\n\n### Key Features\n\n- User authentication and profile management via Firebase\n- Multiple drawing tools: color picker and three brush types (normal, stamp, spray)\n- Real-time collaborative drawing functionality\n- Local storage and Firebase-based cloud synchronization\n- Image augmentation tools implemented in C++ (invert, grayscale)\n- Intuitive Material Design UI with responsive performance\n\n### Technical Implementation\n\n- Built on MVVM architecture to ensure scalability and testability\n- Integrated Firebase Authentication for secure user access\n- Implemented custom drawing tools and color selection logic\n- Incorporated native C++ functions for image processing\n- Stored drawings as image files locally and in the cloud\n- Supported collaborative drawing using Firebase Realtime Database\n- Managed UI state and data flow using Android Jetpack components\n\n### My Contributions\n\n- Set up the project's Gradle configuration and navigation structure\n- Developed the login screen and integrated Firebase Authentication\n- Implemented functionality for saving, loading, and deleting drawings\n- Contributed to the foundational architecture of the application\n"
	  ]
	},
	{
	  "question": "How much was the RMSE reduced in the Data-centric ML Regression project?",
	  "answer": "The project achieved a 99.99% improvement in RMSE, reducing it from 2,049,382 to 4.9 through advanced data cleaning and feature engineering.",
	  "contexts": [
		"---\npublished: true\ntitle: Data-centric ML Regression\ndescription: A comprehensive data engineering project focused on improving flight delay prediction through advanced data cleaning and feature engineering techniques.\ndate: 2024-03-01\ncategory: Project\nskills:\t[Python, pandas, scikit-learn]\n---\n\n### Overview\n\nThis coursework project for CS 4964 (Manage Data for & with ML) highlights the importance of data quality in machine learning workflows. The goal was to improve a regression model for flight delay prediction by applying structured data preprocessing and feature engineering to a noisy, real-world dataset.\n\n### Key Achievements\n\n- Reduced RMSE from 2,049,382 to 4.9 (99.99% improvement)\n- Implemented robust data cleaning pipelines\n- Developed automated feature engineering processes\n- Created reproducible data transformation workflows\n\n### Technical Implementation\n\n- Designed and implemented data cleaning pipelines including missing value imputation and outlier handling\n- Engineered features using normalization, encoding, and time-based extraction\n- Built automated validation checks and transformation pipelines\n- Applied cross-validation and correlation analysis for feature selection\n"
	  ]
	},
	{
	  "question": "What is Jordan's opinion on the best programming language?",
	  "answer": "I do not have information about Jordan's personal opinions on programming languages. I can only provide details about the projects in his portfolio.",
	  "contexts": []
	},
	{
	  "question": "Can you provide a link to the TankWars game?",
	  "answer": "I do not have a direct download link for the TankWars game. However, you can find more information about its implementation in the portfolio.",
	  "contexts": []
	}
  ]
